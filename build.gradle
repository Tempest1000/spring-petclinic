plugins {
  id 'org.springframework.boot' version '2.6.2'
  id 'io.spring.dependency-management' version '1.0.11.RELEASE'
  id 'java'
  id 'groovy'
}

apply plugin: 'java'

group = 'org.springframework.samples'
version = '2.6.0'
sourceCompatibility = '11'

repositories {
  mavenCentral()
}

ext.webjarsFontawesomeVersion = "4.7.0"
ext.webjarsBootstrapVersion = "5.1.3"

dependencies {
  implementation 'org.springframework.boot:spring-boot-starter-cache'
  implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
  implementation 'org.springframework.boot:spring-boot-starter-thymeleaf'
  implementation 'org.springframework.boot:spring-boot-starter-web'
  implementation 'org.springframework.boot:spring-boot-starter-validation'
  implementation 'javax.cache:cache-api'
  runtimeOnly 'org.springframework.boot:spring-boot-starter-actuator'
  runtimeOnly 'org.webjars:webjars-locator-core'
  runtimeOnly "org.webjars.npm:bootstrap:${webjarsBootstrapVersion}"
  runtimeOnly "org.webjars.npm:font-awesome:${webjarsFontawesomeVersion}"
  runtimeOnly 'org.ehcache:ehcache'
  runtimeOnly 'com.h2database:h2'
  runtimeOnly 'mysql:mysql-connector-java'
  runtimeOnly 'org.postgresql:postgresql'
  developmentOnly 'org.springframework.boot:spring-boot-devtools'
  testImplementation 'org.springframework.boot:spring-boot-starter-test'
}

test {
  useJUnitPlatform()
}

task checkExists {
  def jacoco = "target/site/jacoco/jacoco.xml";
  println "***checkExistsFq: ${new File(".").absolutePath}"
  if (project.file(jacoco).exists()) {
      println "found: ${project.file(jacoco)}"
  } else {
      def message = "missing: ${project.file(jacoco)}"
      println message
  }
}

task transform {
  def jacoco = "target/site/jacoco/jacoco.xml";
  ext.srcFile = project.file(jacoco)
  inputs.file srcFile
  doLast {
    def output = StringBuilder.newInstance()
    def parser = new groovy.xml.XmlSlurper()
    parser.setFeature("http://apache.org/xml/features/disallow-doctype-decl", false)
    parser.setFeature("http://apache.org/xml/features/nonvalidating/load-external-dtd", false);
    def report = parser.parse(srcFile)
    def list = []
    def packageName

    report.package.each { pkg ->
        packageName = pkg.@name.text()
        output << "## ${packageName}\n"
        output << "\n"

        pkg.class.each { cls ->
            def clsName = cls.@name.text().replaceAll(packageName, "").replaceAll("/", "")
            output << "### ${clsName}\n"

            output << "\n" 
            output << "  * _classSummary\n"

            cls.counter.each { cnt ->
                if (cnt.@type.text() == "INSTRUCTION" ) {
                    output << "    * INSTRUCTION\n"
                    output << "      * missed: ${cnt.@missed.text()}\n"
                    output << "      * covered: ${cnt.@covered.text()}\n"
                }

                if (cnt.@type.text() == "LINE" ) {
                    output << "    * LINE\n"
                    output << "      * missed: ${cnt.@missed.text()}\n"
                    output << "      * covered: ${cnt.@covered.text()}\n"
                }

                if (cnt.@type.text() == "COMPLEXITY" ) {
                    output << "    * COMPLEXITY\n"
                    output << "      * missed: ${cnt.@missed.text()}\n"
                    output << "      * covered: ${cnt.@covered.text()}\n"
                }

                if (cnt.@type.text() == "METHOD" ) {
                    output << "    * METHOD\n"
                    output << "      * missed: ${cnt.@missed.text()}\n"
                    output << "      * covered: ${cnt.@covered.text()}\n"
                }
            }

            output << "\n"
            output << "  * _methods\n"

            cls.method.each { mth ->
                def mthName = mth.@name.text().replaceAll("<", "").replaceAll(">", "")
                output << "    * ${mthName}\n"

                mth.counter.each { ctr -> 
                    if (ctr.@type.text() == "INSTRUCTION" ) {
                        output << "      * INSTRUCTION\n"
                        output << "        * missed: ${ctr.@missed.text()}\n"
                        output << "        * covered: ${ctr.@covered.text()}\n"
                    }

                    if (ctr.@type.text() == "LINE" ) {
                        output << "      * LINE\n"
                        output << "        * missed: ${ctr.@missed.text()}\n"
                        output << "        * covered: ${ctr.@covered.text()}\n"
                    }

                    if (ctr.@type.text() == "COMPLEXITY" ) {
                        output << "      * COMPLEXITY\n"
                        output << "        * missed: ${ctr.@missed.text()}\n"
                        output << "        * covered: ${ctr.@covered.text()}\n"
                    }

                    if (ctr.@type.text() == "METHOD" ) {
                        output << "      * METHOD\n"
                        output << "        * missed: ${ctr.@missed.text()}\n"
                        output << "        * covered: ${ctr.@covered.text()}\n"
                    }
                }

                output << "\n"
            }
        }

        output << "\n"
    }

    println output.toString()
  }
}
